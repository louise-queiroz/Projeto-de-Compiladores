PARSER_BEGIN(Karloff)
import ast.*;
import java.io.*;
import java.util.ArrayList;
import java.util.List;


public class Karloff {
     ArrayList seqComandos; // Declare sem o tipo genérico

    // Construtor da classe Karloff
    public Karloff() {
        seqComandos = new ArrayList(); // Inicialize o ArrayList aqui
    }

    public static void main(String[] args) throws Exception {
        if (args.length == 0) {
            System.out.println("Por favor, forneça o caminho do arquivo .kar como argumento.");
            return;
        }
        FileInputStream fs = new FileInputStream(new File(args[0]));
        Karloff parser = new Karloff(fs);
        Prog arvore = parser.Karloff(); // Chama o método correto para parsear
        gerarCodigo(arvore, args[0]); // Corrige a chamada para gerarCodigo
    }

    public static void gerarCodigo(Prog arvore, String caminho) { // Corrige o tipo do parâmetro
        String arvoreString;
        File arquivo;
        FileOutputStream saida = null;

        arvoreString = arvore.toString();
        caminho = caminho.replace(".kar", ".c");

        System.out.println(arvoreString); // Corrigido para imprimir no console

        arquivo = new File("saida/" + caminho);
        try {
            arquivo.getParentFile().mkdirs(); // Garante que o diretório de saída existe
            arquivo.createNewFile();
            saida = new FileOutputStream(arquivo);
            saida.write(arvoreString.getBytes()); // Escreve a árvore sintática no arquivo
        } catch (IOException e) {
            e.printStackTrace(); // Adiciona tratamento de exceção
        } finally {
            if (saida != null) {
                try {
                    saida.close(); // Fecha o fluxo de saída
                } catch (IOException e) {
                    e.printStackTrace(); // Adiciona tratamento de exceção
                }
            }
        }
    }
}

PARSER_END(Karloff)

SKIP :
{
    " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
    <MAIN: "main">
| <VOID: "void">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <APARENTESES: "(">
| <FPARENTESES: ")">
| <PONTOVIRGULA: ";">
| <IGUAL: "=">
| <FLOAT: "float">
| <BOOLEAN: "boolean">
| <PRINTOUT: "printOut">
| <NEWVAR: "newVar">
| <IF: "if">
| <THEN: "then">
| <WHILE: "while">
| <READINPUT: "readInput">
| <RETURN: "return">
| <TRUE: "true">
| <FALSE: "false">
| <SOMA: "+">
| <SUBTRACAO: "-">
| <MULTIPLICACAO: "*">
| <DIVISAO: "/">
| <AND: "&">
| <OU: "|">
| <MENOR: "<">
| <MAIOR: ">">
| <IGUALA: "==">
| <VIRGULA: ",">
| <FUN: "fun"> 
}

TOKEN :
{
    <ID: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9"])* ("_" (["a"-"z", "A"-"Z", "0"-"9"])+)* >
|  < NUM: (["0"-"9"])+ ("." (["0"-"9"])+)? (["e", "E"] (["+", "-"])? (["0"-"9"])+)? >
}

Prog Karloff() :
{
    ArrayList<VarDecl> vardecls;
    ArrayList<Comando> comandos;
}
{
    vardecls = Vardecl() // Chamando a função que coleta as declarações de variáveis
    comandos = SeqComandos() // Chamando a função que coleta os comandos
    {
        // Retorna um novo objeto Prog, que deve incluir o Main
        return new Prog(new Main(vardecls, comandos), new ArrayList<Fun>()); 
    }
}

Prog Main() :
{
    ArrayList<VarDecl> vardecls = new ArrayList<VarDecl>();
    ArrayList<Comando> comandos = new ArrayList<Comando>();
}
{
    <VOID> <MAIN> <APARENTESES> <FPARENTESES> <ACHAVES>
    vardecls = Vardecl()
    comandos = SeqComandos() 
    <FCHAVES>
    {
        // Retorna um novo objeto Prog, incluindo o Main e uma lista vazia de funções
        return new Prog(new Main(vardecls, comandos), new ArrayList<Fun>());
    }
}

ArrayList<Comando> SeqComandos() :
{
    ArrayList<Comando> comandos = new ArrayList<Comando>();
    Comando cmd;
}
{
    (cmd = Comando() { 
        comandos.add(cmd); 
    })*
    { 
        return comandos;
    }
}

ArrayList<VarDecl> Vardecl() :
{
    ArrayList<VarDecl> decls = new ArrayList<VarDecl>();
    String tipo;
    Token id;
}
{
    ( <NEWVAR> tipo = Tipo() id = <ID> <PONTOVIRGULA> { 
        decls.add(new VarDecl(tipo, id.image)); 
    } Vardecl() )*
    {
        return decls;
    }
}

String Tipo() :
{
    Token tipo;
}
{
    tipo = <FLOAT> { return "float"; }
|
    tipo = <BOOLEAN> { return "boolean"; }
|
    tipo = <VOID> { return "void"; }
}

Comando Comando() :
{
    Comando cmd = null;
    Exp exp = null;
    Token id;
    ArrayList<Comando> seqComandos;
}
{
    id = <ID> ComandoLinha1() {
        cmd = new CAtribuicao(0, id.image, null); 
        return cmd;
    }
|
    <IF> <APARENTESES> exp = Exp() <FPARENTESES> <THEN> <ACHAVES>
    seqComandos = SeqComandos() <FCHAVES> {
        cmd = new CIf(0, exp, seqComandos);
        return cmd;
    }
|
    <WHILE> <APARENTESES> exp = Exp() <FPARENTESES> <ACHAVES>
    seqComandos = SeqComandos() <FCHAVES> {
        cmd = new CWhile(0, exp, seqComandos);
        return cmd;
    }
|
    <RETURN> exp = Exp() <PONTOVIRGULA> {
        cmd = new CReturn(0, exp); 
        return cmd;
    }
|
    <PRINTOUT> <APARENTESES> exp = Exp() <FPARENTESES> <PONTOVIRGULA> {
        cmd = new CPrint(0, exp);
        return cmd;
    }
|
    <READINPUT> <APARENTESES> <FPARENTESES> <PONTOVIRGULA> {
        cmd = new CReadInput(0, "entrada");
        return cmd;
    }
}

Comando ComandoLinha1() :
{
    Comando cmd = null;
}
{
    <PONTOVIRGULA> { return cmd; }
|
    Comando() { return cmd; }
}

Exp Exp() :
{
    Exp exp1, exp2;
    String op;
}
{
    <APARENTESES> exp1 = Exp() op = Op() exp2 = Exp() <FPARENTESES> {
        return new EOpExp(op, exp1, exp2);
    }
|
    exp1 = Fator() {
        return exp1;
    }
}

String Op() :
{
    Token op;
}
{
    op = <SOMA> { return "+"; }
|
    op = <SUBTRACAO> { return "-"; }
|
    op = <MULTIPLICACAO> { return "*"; }
|
    op = <DIVISAO> { return "/"; }
}

Exp Fator() :
{
    Exp exp;
    Token num, id;
}
{
    num = <NUM> { return new EFloat(Float.parseFloat(num.image)); }
|
    id = <ID> { return new EVar(id.image); }
}
