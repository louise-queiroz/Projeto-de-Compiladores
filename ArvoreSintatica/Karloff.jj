PARSER_BEGIN(Karloff)

import ast.*;
import java.io.*;
import java.util.ArrayList;
import java.util.List;

public class Karloff {
    public static void main(String args[]) throws Exception {
        FileInputStream file = new FileInputStream(new File(args[0]));
        Karloff parser = new Karloff(file);
        Prog arvore = parser.Karloff();
        gerarCodigo(arvore, args[0]);
    }

    public static void gerarCodigo(Prog arvore, String caminho) {
        String arvoreString;
        File arquivo;
        FileOutputStream saida = null;

        arvoreString = arvore.toString();
        caminho = caminho.replace(".kar", ".c");

        System.out.println("Conteúdo gerado para o arquivo C: " + arvoreString);

        arquivo = new File("saida/" + caminho);
        try {
            arquivo.getParentFile().mkdirs();
            arquivo.createNewFile();
            saida = new FileOutputStream(arquivo);
            saida.write(arvoreString.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (saida != null) {
                try {
                    saida.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

PARSER_END(Karloff)

SKIP :
{
    " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
    <MAIN: "main">
| <VOID: "void">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <APARENTESES: "(">
| <FPARENTESES: ")">
| <PONTOVIRGULA: ";">
| <IGUAL: "=">
| <FLOAT: "float">
| <BOOLEAN: "boolean">
| <PRINTOUT: "printOut">
| <NEWVAR: "newVar">
| <IF: "if">
| <THEN: "then">
| <WHILE: "while">
| <READINPUT: "readInput">
| <RETURN: "return">
| <TRUE: "true">
| <FALSE: "false">
| <SOMA: "+">
| <SUBTRACAO: "-">
| <MULTIPLICACAO: "*">
| <DIVISAO: "/">
| <AND: "&">
| <OU: "|">
| <MENOR: "<">
| <MAIOR: ">">
| <IGUALA: "==">
| <VIRGULA: ",">
| <FUN: "fun">
}

TOKEN :
{
    <ID: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9"])* ("_" (["a"-"z", "A"-"Z", "0"-"9"])+)* >
|  <NUM: (["0"-"9"])+ ("." (["0"-"9"])+)? (["e", "E"] (["+", "-"])? (["0"-"9"])+)? >
}

// Nova regra para o programa principal
Prog Karloff() :
{
    Main main = null;
    ArrayList<VarDecl> vardecls = new ArrayList<VarDecl>();
    ArrayList<Comando> comandos = new ArrayList<Comando>();
}
{
    (
      main = Main()
    |
      vardecls = Vardecl() 
      comandos = SeqComandos()
    )
    {
        if (main == null) {
            System.out.println("Programa sem main explícito.");
            main = new Main(vardecls, comandos);
        }
        return new Prog(main, new ArrayList<Fun>());
    }
}
Main Main() :
{
    ArrayList<VarDecl> vardecls;
    ArrayList<Comando> comandos;
}
{
    <VOID> <MAIN> <APARENTESES> <FPARENTESES> <ACHAVES>
    vardecls = Vardecl()
    comandos = SeqComandos()
    <FCHAVES>
    {
        System.out.println("Dentro de Main - Número de variáveis: " + vardecls.size());
        System.out.println("Dentro de Main - Número de comandos: " + comandos.size());
        return new Main(vardecls, comandos);
    }
}


ArrayList<Comando> SeqComandos() :
{
    ArrayList<Comando> comandos = new ArrayList<Comando>();
    Comando cmd;
}
{
    (cmd = Comando() {
        comandos.add(cmd);
    })*
    { 
        return comandos;  // Retorna os comandos coletados
    }
}

ArrayList<VarDecl> Vardecl() :
{
    ArrayList<VarDecl> decls = new ArrayList<VarDecl>();
    String tipo;
    Token id;
}
{
    ( <NEWVAR> tipo = Tipo() id = <ID> <PONTOVIRGULA> { 
        System.out.println("Nova variável declarada: tipo=" + tipo + ", id=" + id.image);

        decls.add(new VarDecl(tipo, id.image));
    } )*
    {
        return decls;
    }
}


String Tipo() :
{
    Token tipo;
}
{
    tipo = <FLOAT> { return "float"; }
|
    tipo = <BOOLEAN> { return "boolean"; }
|
    tipo = <VOID> { return "void"; }
}

Comando Comando() :
{
    Comando cmd = null;
    Exp exp = null;
    Token id;
    ArrayList<Comando> seqComandos = new ArrayList<Comando>();
}
{
    // Atribuição
    id = <ID> <IGUAL> exp = Exp() <PONTOVIRGULA> {
        cmd = new CAtribuicao(0, id.image, exp); // Atribuição
        System.out.println("Comando de atribuição: id=" + id.image + ", exp=" + exp);
        return cmd;
    }
    |
    LOOKAHEAD(3) <PRINTOUT> <APARENTESES> exp = Exp() <FPARENTESES> <PONTOVIRGULA> {
        cmd = new CPrint(0, exp);
        System.out.println("Comando PRINTOUT: exp=" + exp);
        return cmd;
    }
    |
    LOOKAHEAD(3) <PRINTOUT> id = <ID> <PONTOVIRGULA> {
        exp = new EVar(id.image);
        cmd = new CPrint(0, exp);
        System.out.println("Comando PRINTOUT: var=" + id.image);
        return cmd;
    }
    |
    <IF> <APARENTESES> exp = Exp() <FPARENTESES> <THEN> <ACHAVES>
    {
        seqComandos = SeqComandos();

        cmd = new CIf(0, exp, seqComandos);
        return cmd;
    }
    |
    <WHILE> <APARENTESES> exp = Exp() <FPARENTESES> <ACHAVES>
    {
        seqComandos = SeqComandos();
        System.out.println("Comando WHILE: exp=" + exp);
        cmd = new CWhile(0, exp, seqComandos);
        return cmd;
    }
    |
    <RETURN> exp = Exp() <PONTOVIRGULA> {
        cmd = new CReturn(0, exp);
        System.out.println("Comando RETURN: exp=" + exp);
        return cmd;
    }
    |
    <READINPUT> <APARENTESES> <FPARENTESES> <PONTOVIRGULA> {
        cmd = new CReadInput(0, "entrada");
        return cmd;
    }
}
Comando ComandoLinha1() :
{
    Comando cmd = null;
}
{
    <PONTOVIRGULA> { return cmd; }
|
    Comando() { return cmd; }
}

Exp Exp() :
{
    Exp exp1, exp2;
    String op;
}
{
    exp1 = Fator() 
    (
        op = Op() exp2 = Fator() {
            exp1 = new EOpExp(op, exp1, exp2);
        }
    )*
    {
        return exp1;
    }
}



String Op() :
{
    Token op;
}
{
    op = <SOMA> { return "+"; }
| 
    op = <SUBTRACAO> { return "-"; }
| 
    op = <MULTIPLICACAO> { return "*"; }
| 
    op = <DIVISAO> { return "/"; }
| 
    op = <MENOR> { return "<"; } // adicionar comparação se necessário
| 
    op = <MAIOR> { return ">"; }
| 
    op = <IGUALA> { return "=="; } // adicionar comparação se necessário
}

Exp Fator() :
{
    Exp exp;
    Token num, id;
}
{
    num = <NUM> { return new EFloat(Float.parseFloat(num.image)); }
|
    id = <ID> { return new EVar(id.image); }
}
