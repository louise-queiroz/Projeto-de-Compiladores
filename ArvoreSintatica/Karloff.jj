PARSER_BEGIN(Karloff)

import ast.*;
import java.io.*;
import java.util.ArrayList;
import java.util.List;

public class Karloff {
  public static void main(String args[]) throws Exception {  
    FileInputStream file = new FileInputStream(new File(args[0]));
    Karloff parser = new Karloff(file);
    Prog arvore = parser.Karloff();
    gerarCodigo(arvore, args[0]);
  }

  public static void gerarCodigo(Prog arvore, String caminho) {
    String arvoreString;
    File arquivo;
    FileOutputStream saida = null;

    arvoreString = arvore.toString();
    caminho = caminho.replace(".kar", ".c");

    System.out.println(arvoreString);

    arquivo = new File("saida/" + caminho);
    try {
      arquivo.getParentFile().mkdirs();
      arquivo.createNewFile();
      saida = new FileOutputStream(arquivo);
      saida.write(arvoreString.getBytes());
    } catch (IOException e) {
      e.printStackTrace();
    } finally {
      if (saida != null) {
        try {
          saida.close();
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
    }
  }
}

PARSER_END(Karloff)

SKIP :
{
    " "
| "\t"
| "\n"
| "\r"
}

TOKEN :
{
    <MAIN: "main">
| <VOID: "void">
| <ACHAVES: "{">
| <FCHAVES: "}">
| <APARENTESES: "(">
| <FPARENTESES: ")">
| <PONTOVIRGULA: ";">
| <IGUAL: "=">
| <FLOAT: "float">
| <BOOLEAN: "boolean">
| <PRINTOUT: "printOut">
| <NEWVAR: "newVar">
| <IF: "if">
| <THEN: "then">
| <WHILE: "while">
| <READINPUT: "readInput">
| <RETURN: "return">
| <TRUE: "true">
| <FALSE: "false">
| <SOMA: "+">
| <SUBTRACAO: "-">
| <MULTIPLICACAO: "*">
| <DIVISAO: "/">
| <AND: "&">
| <OU: "|">
| <MENOR: "<">
| <MAIOR: ">">
| <IGUALA: "==">
| <VIRGULA: ",">
| <FUN: "fun">
}

TOKEN :
{
    <ID: ["a"-"z", "A"-"Z"] (["a"-"z", "A"-"Z", "0"-"9"])* ("_" (["a"-"z", "A"-"Z", "0"-"9"])+)* >
|  <NUM: (["0"-"9"])+ ("." (["0"-"9"])+)? (["e", "E"] (["+", "-"])? (["0"-"9"])+)? >
}

Prog Karloff() :
{
    ArrayList<VarDecl> vardecls;
    ArrayList<Comando> comandos;
}
{
    vardecls = Vardecl() 
    comandos = SeqComandos() 
    {
        return new Prog(new Main(vardecls, comandos), new ArrayList<Fun>());
    }
}

ArrayList<Comando> SeqComandos() :
{
    ArrayList<Comando> comandos = new ArrayList<Comando>();
    Comando cmd;
}
{
    (cmd = Comando() { 
        comandos.add(cmd); 
    })*
    { 
        return comandos;
    }
}

ArrayList<VarDecl> Vardecl() :
{
    ArrayList<VarDecl> decls = new ArrayList<VarDecl>();
    String tipo;
    Token id;
}
{
    ( <NEWVAR> tipo = Tipo() id = <ID> <PONTOVIRGULA> { 
        decls.add(new VarDecl(tipo, id.image)); 
    } Vardecl() )*
    {
        return decls;
    }
}


String Tipo() :
{
    Token tipo;
}
{
    tipo = <FLOAT> { return "float"; }
|
    tipo = <BOOLEAN> { return "boolean"; }
|
    tipo = <VOID> { return "void"; }
}

Comando Comando() :
{
    Comando cmd = null;
    Exp exp = null;
    Token id;
    ArrayList<Comando> seqComandos;
}
{
    id = <ID> ComandoLinha1() {
        // Atribuição
        cmd = new CAtribuicao(0, id.image, null); 
        return cmd;
    }
    |
    <IF> <APARENTESES> exp = Exp() <FPARENTESES> <THEN> <ACHAVES>
    seqComandos = SeqComandos() <FCHAVES> {
        // Comando IF
        cmd = new CIf(0, exp, seqComandos);
        return cmd;
    }
    |
    <WHILE> <APARENTESES> exp = Exp() <FPARENTESES> <ACHAVES>
    seqComandos = SeqComandos() <FCHAVES> {
        // Comando WHILE
        cmd = new CWhile(0, exp, seqComandos);
        return cmd;
    }
    |
    <RETURN> exp = Exp() <PONTOVIRGULA> {
        // Comando RETURN
        cmd = new CReturn(0, exp); 
        return cmd;
    }
    |
    <PRINTOUT> <APARENTESES> exp = Exp() <FPARENTESES> <PONTOVIRGULA> {
        // Comando PRINT
        cmd = new CPrint(0, exp);
        return cmd;
    }
    |
    <READINPUT> <APARENTESES> <FPARENTESES> <PONTOVIRGULA> {
        // Comando de Leitura
        cmd = new CReadInput(0, "entrada");
        return cmd;
    }
}
Comando ComandoLinha1() :
{
    Comando cmd = null;
}
{
    <PONTOVIRGULA> { return cmd; }
|
    Comando() { return cmd; }
}

Exp Exp() :
{
    Exp exp1, exp2;
    String op;
}
{
    <APARENTESES> exp1 = Exp() op = Op() exp2 = Exp() <FPARENTESES> {
        return new EOpExp(op, exp1, exp2);
    }
    |
    exp1 = Fator() {
        return exp1;
    }
}

String Op() :
{
    Token op;
}
{
    op = <SOMA> { return "+"; }
|
    op = <SUBTRACAO> { return "-"; }
|
    op = <MULTIPLICACAO> { return "*"; }
|
    op = <DIVISAO> { return "/"; }
}

Exp Fator() :
{
    Exp exp;
    Token num, id;
}
{
    num = <NUM> { return new EFloat(Float.parseFloat(num.image)); }
|
    id = <ID> { return new EVar(id.image); }
}
